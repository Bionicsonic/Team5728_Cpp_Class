//2.2 Variables

/*
Variables provide storage for values that our programs will use, each variable has 
a type, which determines its size and layout of the variable in memory, as well
as the set of operations able to be applied to said variable. Objects and Variables 
are largely exchangeable terms so you know they refer to the same basic idea of storing
some sort of information.
*/

//2.2.1 Variable Definitions

/*
Variable defintions consist of a type specifier followed by one or a list
of variable names and their designated values seperated by commas and ending with 
a semicolon. 
*/

int sum = 0, value, 
	units_sold = 0; //All 3 variables are of type integer, two are init'd with value 0
Sales_item item;
std::string book("0-201-78345-X"); //book init'd from string library type

/*
On the fourth line of code we see the line 'std::string'. What this is telling us is
that 'string' is derived from the 'std' namespace. A namespace is just a group of preset
types, functions, and variables used in case we have more than one library in our code 
that are using the same variables, functions, or types. Basically we're just specifying
location. So, 'std', is our namespace, '::' is telling us our scope(which means its 
located within namespace 'std'), and string is most likely a function in 'std'. 

Ultimately string is defined in iostream, like cin and cout, so the compiler knows
which actions pertain to the code 'book("0-201-78345-X")'.

Initializers

When we're creating variables the values we assign them with or 'initialize' them
with don't always have to be static numbers, strings, or booleans. In fact we can
initialize them with functions such as what is demonstrated in the book's code shown
below
*/

double price = 109.99, discout = price * 0.16;
double salesPrice = appleDiscount(price, discount);

/*
What our psuedo-code is showing us is that we are able to create variables that
contain expressions dependent on other variables, we can do this when we want to
simplify our code by calling a variable instead of making a function or rewriting
the code. Thus variables do not have to hold pre-known values, rather they can store
an equivalent expression of any complicated degree to what we would like the end
result to be. It is important to note that assignment and initialization are two
seperate things, initialization occurs when we first create an object/variable and
give it a value to hold, whereas assignment is when we obliterate this value to give
the object a new one.

List Initialization

New syntax within C++11 standard as dictated by the gods, tells us that we can initialize
variables in several different ways, namely: 
*/

0:
	int units_sold = 0;
	int units_sold = {0};
	int units_sold{0};
	int units_sold(0);

/*
You can largely ignore this part for now, the important concept to take away is in the
last paragraph. 'This form of initialization has one important property: The compiler
will not let us initialize variables of built-in types if the initializer might lead to
the loss of information' This is demonstrated below.
*/

long double ld = 3.1415926536
int a{ld}, b = {ld}; //Error: narrowing conversion
int c(ld)) d = ld; //Ok but value truncated

/*
Whats occuring here is that the compiler sees with the variables a and b that they are 
of type int whereas the source they are drawing from is of type long double, so data
will likely be lost thus initialization fails. With variables c and d, at best the data
will be shortened to just the whole number value but again most likely data loss will 
occur and thus we'll get an error. Important to know when debugging your code.

Default Initialization

This is bascially the name for what happens when we create/initialize a variable without
giving it a value to hold. These variables are given a 'default' value depending on the 
type of variable they are and where it was defined. Variables outside a function are 
initialized to 0 and those within functions are uninitialized which gives the variables a 
value of 'undefined'. Undefined is one of the few values on which no operation can be done.
All of that occurs relative to built-in types (int, float, bool, char, etc.). Additionally 
it is important to note that when we create variables from classes that aren't initialized
meaning we dont explicitaly give it a type, the class should provide a default type for that
variable/object.
*/

std::string empty; //Class string will supply the type of 'char' and give us an empty string
Sales_item item; //this will give us the default-type of whatever is specified in the Sale_item code


//Exercises

//2.9

//(a)
/*
Variables must be initialized before taking in any input, so this would return an error.
*/
//(b)
/*
'int' traditionally holds whole number values while the value provided is a float. Thus an
error will occur because of difference in type.
*/
//(c)
/*
This code will produce an error because variable wage was not initialized so it will be given
an error. You can fix this by initalizing wage to be a double write above the salary initializer
*/
//(d)
/*
Again type difference, value will be truncated. 
*/

//2.10
/*
 - global_str has the value of an empty string
 - global_int has the value of 0
 - local_int has the value of undefined
 - local_str has the value of empty string because although its in a function it is defined by a 
   class to be an empty string
*/
